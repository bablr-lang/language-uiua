/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./grammar.macro.js#171e775b8cdc9d10e6c6eba9868d7dd666820fec
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
let _initProto, _ExpressionDecs, _ArrayDecs, _ObjectDecs, _StringDecs, _EscapeSequenceDecs, _NumberDecs, _BooleanDecs, _NullDecs, _KeywordDecs, _PunctuatorDecs, _ListDecs, _AnyDecs;
import { i } from '@bablr/boot';
import { triviaEnhancer } from '@bablr/helpers/trivia';
import * as productions from '@bablr/helpers/productions';
import { buildString } from '@bablr/agast-vm-helpers';
import { Node, CoveredBy, AllowEmpty, InjectFrom, Attributes } from '@bablr/helpers/decorators';
import * as Space from '@bablr/language-blank-space';
export const dependencies = {
  Space
};
export const canonicalURL = 'https://github.com/bablr-lang/language-uiua';
export const escapables = new Map(Object.entries({
  b: '\b',
  f: '\f',
  n: '\n',
  r: '\r',
  t: '\t',
  '\\': '\\',
  '/': '/'
}));
export const grammar = triviaEnhancer({
  triviaIsAllowed: s => s.span === 'Bare',
  *eatMatchTrivia() {
    if (yield i`match(/[ \n\r\t]/)`) {
      yield i`eat(<#*Space:Space>)`;
    }
  }
}, class JSONGrammar {
  static {
    [_initProto] = _applyDecs(this, [[_ExpressionDecs, 2, "Expression"], [_ArrayDecs, 2, "Array"], [_ObjectDecs, 2, "Object"], [Node, 2, "Property"], [_StringDecs, 2, "String"], [[AllowEmpty, Node], 2, "StringContent"], [_EscapeSequenceDecs, 2, "EscapeSequence"], [Node, 2, "EscapeCode"], [_NumberDecs, 2, "Number"], [Node, 2, "Integer"], [Node, 2, "Digit"], [_BooleanDecs, 2, "Boolean"], [_NullDecs, 2, "Null"], [_KeywordDecs, 2, "Keyword"], [_PunctuatorDecs, 2, "Punctuator"], [_ListDecs, 2, "List"], [_AnyDecs, 2, "Any"]], []).e;
  }
  constructor() {
    _initProto(this);
  }
  *[(_ExpressionDecs = CoveredBy('Element'), _ArrayDecs = [CoveredBy('Expression'), Node], _ObjectDecs = [CoveredBy('Expression'), Node], _StringDecs = [CoveredBy('Language'), Node], _EscapeSequenceDecs = [Attributes(['cooked']), Node], _NumberDecs = [CoveredBy('Expression'), Node], _BooleanDecs = [CoveredBy('Expression'), Node], _NullDecs = [CoveredBy('Expression'), Node], _KeywordDecs = [Node, InjectFrom(productions)], _PunctuatorDecs = [Node, InjectFrom(productions)], _ListDecs = InjectFrom(productions), _AnyDecs = InjectFrom(productions), "Expression")]() {
    yield i`eat(<Any> null [
        <Array '['>
        <Object '{'>
        <String '"'>
        <Number /-?\d/ span='Number'>
        <Null 'null'>
        <Boolean /true|false/>
      ])`;
  }
  *Array() {
    yield i`eat(<~*Punctuator '[' balanced=']'> 'openToken')`;
    yield i`eat(<List> 'elements[]' {
        element: <Expression>
        separator: <~*Punctuator ','>
        allowTrailingSeparator: false
      })`;
    yield i`eat(<~*Punctuator ']' balancer> 'closeToken')`;
  }
  *Object() {
    yield i`eat(<~*Punctuator '{' balanced='}'> 'openToken')`;
    yield i`eat(<List> 'properties[]' {
        element: <Property>
        separator: <~*Punctuator ','>
        allowTrailingSeparator: false
      })`;
    yield i`eat(<~*Punctuator '}' balancer> 'closeToken')`;
  }
  *Property() {
    yield i`eat(<String> 'key')`;
    yield i`eat(<~*Punctuator ':'> 'sigilToken')`;
    yield i`eat(<Expression> 'value')`;
  }
  *String() {
    yield i`eat(<~*Punctuator '"' balanced='"' balancedSpan='String'> 'openToken')`;
    yield i`eat(<*StringContent> 'content')`;
    yield i`eat(<~*Punctuator '"' balancer> 'closeToken')`;
  }
  *StringContent() {
    let esc, lit;
    do {
      esc = (yield i`match('\\')`) && (yield i`eat(<@EscapeSequence>)`);
      lit = yield i`eatMatch(/[^\r\n\\"]+/)`;
    } while (esc || lit);
  }
  *EscapeSequence({
    state: {
      span
    },
    ctx
  }) {
    if (!span.startsWith('String')) {
      yield i`fail()`;
    }
    yield i`eat(<~*Punctuator '\\'> 'sigilToken')`;
    let match, cooked;
    if (match = yield i`match(/[\\/bfnrt"]/)`) {
      const match_ = ctx.sourceTextFor(match);
      yield i`eat(<~*Keyword ${buildString(match_)}> 'value')`;
      cooked = escapables.get(match_) || match_;
    } else if (yield i`match('u')`) {
      const codeNode = yield i`eat(<EscapeCode> 'value')`;
      cooked = parseInt(ctx.getProperty(codeNode, 'digits').map(digit => ctx.sourceTextFor(digit)).join(''), 16);
    } else {
      yield i`fail()`;
    }
    yield i`bindAttribute(cooked ${buildString(cooked.toString(10))})`;
  }
  *EscapeCode() {
    yield i`eat(<~*Keyword 'u'> 'typeToken')`;
    yield i`eat(<Digits> 'digits[]')`;
  }
  *Number() {
    yield i`eat(<Integer> 'wholePart' { no00: true matchSign: '-' })`;
    let fs = yield i`eatMatch(<~*Punctuator '.'> 'fractionalSeparatorToken')`;
    if (fs) {
      yield i`eat(<Integer> 'fractionalPart')`;
    } else {
      yield i`eat(null 'fractionalPart')`;
    }
    let es = yield i`eatMatch(<~*Punctuator /[eE]/> 'exponentSeparatorToken')`;
    if (es) {
      yield i`eat(<Integer> 'exponentPart' { matchSign: /[+-]/ })`;
    } else {
      yield i`eat(null 'exponentPart')`;
    }
  }
  *Integer({
    value: props,
    ctx
  }) {
    const {
      matchSign = null,
      no00 = false
    } = props && ctx.unbox(props) || {};
    if (matchSign) {
      yield i`eatMatch(<~*Punctuator ${matchSign}> 'signToken')`;
    } else {
      yield i`eat(null 'signToken')`;
    }
    let [firstDigit] = ctx.ownTerminalsFor(yield i`eat(<*Digit> 'digits[]')`);
    if (!no00 || firstDigit.value !== '0') {
      while (yield i`eatMatch(<*Digit> 'digits[]')`);
    }
  }
  *Digit() {
    yield i`eat(/\d/)`;
  }
  *Boolean() {
    yield i`eat(<~*Keyword /true|false/> 'sigilToken')`;
  }
  *Null() {
    yield i`eat(<~*Keyword 'null'> 'sigilToken')`;
  }
  *Keyword() {}
  *Punctuator() {}
  *List() {}
  *Any() {}
});